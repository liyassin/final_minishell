void	handle_redirection(t_ast *ast)
{
    int fd;

    // Handle output redirection ">"
    if (ast->output_file)
    {
        fd = open(ast->output_file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
        if (fd == -1)
        {
            perror("Error opening file for writing");
            return;
        }
        // Replace standard output (stdout) with the file
        if (close(STDOUT_FILENO) == -1 || close(fd) == -1)
        {
            perror("Error closing standard output");
            return;
        }
        // Reopen the file descriptor as standard output
        if (open(ast->output_file, O_WRONLY | O_CREAT | O_TRUNC, 0644) == -1)
        {
            perror("Error reopening file for output");
            return;
        }
        // Remove the redirection operator from args to avoid it being passed to execve
        ast->args = remove_redirection_operator(ast->args, ">");
    }
    // Handle input redirection "<"
    if (ast->input_file)
    {
        fd = open(ast->input_file, O_RDONLY);
        if (fd == -1)
        {
            perror("Error opening file for reading");
            return;
        }
        // Replace standard input (stdin) with the file
        if (close(STDIN_FILENO) == -1 || close(fd) == -1)
        {
            perror("Error closing standard input");
            return;
        }
        // Reopen the file descriptor as standard input
        if (open(ast->input_file, O_RDONLY) == -1)
        {
            perror("Error reopening file for input");
            return;
        }
        // Remove the redirection operator from args to avoid it being passed to execve
        ast->args = remove_redirection_operator(ast->args, "<");
    }
}

// char *ft_strtok(char *str, const char *delim)
// {
// 	static char *backup;
// 	char *token;
// 	if (str != NULL)
// 		backup = str;
// 	else if (backup == NULL)
// 		return NULL;
// 	while (*backup && strchr(delim, *backup))
// 		backup++;
// 	if (*backup == '\0')
// 		return NULL;
// 	token = backup;
// 	while (*backup && !strchr(delim, *backup))
// 		backup++;
// 	if (*backup)
// 	{
// 		*backup = '\0';
// 		backup++;
// 	}
// 	else
// 		backup = NULL;
// 	return token;
// }

// char    **tokenize_input(char *input)
// {
// 	char    **tokens;
// 	char    *token;
// 	char    *delimiters;
// 	int     i;
// 	tokens = malloc(64 * sizeof(char *));
// 	delimiters = " \t\n"; // split by space, tab, newline
// 	if (!tokens)
// 	{
// 		perror ("malloc");
// 		exit(EXIT_FAILURE);
// 	}
// 	token = ft_strtok(input, delimiters);
// 	i = 0;
// 	while (token)
// 	{
// 		tokens[i++] = token;
// 		token = ft_strtok(NULL, delimiters);
// 	}
// 	tokens[i] = NULL;
// 	return (tokens);
// }

void handle_redirection(t_ast *ast)
{
    int fd;

    // Handle output redirection ">"
    if (ast->output_file)
    {
        fd = open(ast->output_file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
        if (fd == -1)
        {
            perror("Error opening file for writing");
            exit(EXIT_FAILURE);
        }
        if (dup2(fd, STDOUT_FILENO) == -1)
        {
            perror("dup2 failed for output redirection");
            close(fd);
            exit(EXIT_FAILURE);
        }
        close(fd); // Close the file descriptor after duplicating
    }

    // Handle input redirection "<"
    if (ast->input_file)
    {
        fd = open(ast->input_file, O_RDONLY);
        if (fd == -1)
        {
            perror("Error opening file for reading");
            exit(EXIT_FAILURE);
        }
        if (dup2(fd, STDIN_FILENO) == -1)
        {
            perror("dup2 failed for input redirection");
            close(fd);
            exit(EXIT_FAILURE);
        }
        close(fd); // Close the file descriptor after duplicating
    }
}

// Executes a single command from the AST
void exec_command(t_ast *ast, char **envp)
{
    pid_t pid;
    int status;
    char *full_path;

    pid = fork();
    if (pid == 0)
    {
        // Child process
        handle_redirection(ast); // Ensure redirection is handled
        full_path = find_command_path(ast->command, envp);
        if (full_path)
        {
            execve(full_path, ast->args, envp);
            perror("execve failed");
            free(full_path);
            exit(EXIT_FAILURE);
        }
        else
        {
            ft_putstr_fd(ast->command, 2);
            ft_putstr_fd(": command not found\n", 2);
            exit(127); // Command not found exit status
        }
    }
    else if (pid < 0)
    {
        perror("fork failed");
    }
    else
    {
        // Parent process
        waitpid(pid, &status, 0);
    }
}
